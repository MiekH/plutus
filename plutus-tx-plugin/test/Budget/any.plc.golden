(program
  (let
    (rec)
    (datatypebind
      (datatype
        (tyvardecl List (fun (type) (type)))
        (tyvardecl a (type))
        Nil_match
        (vardecl Nil [ List a ])
        (vardecl Cons (fun a (fun [ List a ] [ List a ])))
      )
    )
    (let
      (nonrec)
      (datatypebind
        (datatype
          (tyvardecl Monoid (fun (type) (type)))
          (tyvardecl a (type))
          Monoid_match
          (vardecl
            CConsMonoid
            (fun [ (lam a (type) (fun a (fun a a))) a ] (fun a [ Monoid a ]))
          )
        )
      )
      (let
        (rec)
        (termbind
          (strict)
          (vardecl
            fFoldableNil_cfoldMap
            (all
              m
              (type)
              (all
                a (type) (fun [ Monoid m ] (fun (fun a m) (fun [ List a ] m)))
              )
            )
          )
          (abs
            m
            (type)
            (abs
              a
              (type)
              (lam
                dMonoid
                [ Monoid m ]
                (lam
                  ds
                  (fun a m)
                  (lam
                    ds
                    [ List a ]
                    [
                      [
                        { [ { Nil_match a } ds ] m }
                        (lam
                          p
                          (prod )
                          [
                            { [ { Monoid_match m } dMonoid ] m }
                            (lam
                              p
                              (prod [ (lam a (type) (fun a (fun a a))) m ] m)
                              (proj 1 p)
                            )
                          ]
                        )
                      ]
                      (lam
                        p
                        (prod a [ List a ])
                        [
                          [
                            [
                              {
                                [ { Monoid_match m } dMonoid ]
                                [ (lam a (type) (fun a (fun a a))) m ]
                              }
                              (lam
                                p
                                (prod [ (lam a (type) (fun a (fun a a))) m ] m)
                                (proj 0 p)
                              )
                            ]
                            [ ds (proj 0 p) ]
                          ]
                          [
                            [ [ { { fFoldableNil_cfoldMap m } a } dMonoid ] ds ]
                            (proj 1 p)
                          ]
                        ]
                      )
                    ]
                  )
                )
              )
            )
          )
        )
        (let
          (nonrec)
          (datatypebind
            (datatype
              (tyvardecl AdditiveMonoid (fun (type) (type)))
              (tyvardecl a (type))
              AdditiveMonoid_match
              (vardecl
                CConsAdditiveMonoid
                (fun
                  [ (lam a (type) (fun a (fun a a))) a ]
                  (fun a [ AdditiveMonoid a ])
                )
              )
            )
          )
          (datatypebind
            (datatype
              (tyvardecl Bool (type))

              Bool_match
              (vardecl True Bool) (vardecl False Bool)
            )
          )
          [
            [
              [
                {
                  { fFoldableNil_cfoldMap [ (lam a (type) a) Bool ] }
                  (con integer)
                }
                (let
                  (nonrec)
                  (termbind
                    (strict)
                    (vardecl v [ AdditiveMonoid Bool ])
                    [
                      [
                        { CConsAdditiveMonoid Bool }
                        (lam
                          l
                          Bool
                          (lam
                            r
                            Bool
                            [
                              [ { [ Bool_match l ] Bool } (lam p (prod ) True) ]
                              (lam p (prod ) r)
                            ]
                          )
                        )
                      ]
                      False
                    ]
                  )
                  [
                    [
                      { CConsMonoid [ (lam a (type) a) Bool ] }
                      (lam
                        eta
                        [ (lam a (type) a) Bool ]
                        (lam
                          eta
                          [ (lam a (type) a) Bool ]
                          [
                            [
                              [
                                {
                                  [ { AdditiveMonoid_match Bool } v ]
                                  [ (lam a (type) (fun a (fun a a))) Bool ]
                                }
                                (lam
                                  p
                                  (prod
                                    [ (lam a (type) (fun a (fun a a))) Bool ]
                                    Bool
                                  )
                                  (proj 0 p)
                                )
                              ]
                              eta
                            ]
                            eta
                          ]
                        )
                      )
                    ]
                    [
                      { [ { AdditiveMonoid_match Bool } v ] Bool }
                      (lam
                        p
                        (prod [ (lam a (type) (fun a (fun a a))) Bool ] Bool)
                        (proj 1 p)
                      )
                    ]
                  ]
                )
              ]
              (lam
                y
                (con integer)
                [
                  [
                    [
                      { (builtin ifThenElse) Bool }
                      [ [ (builtin lessThanEqualsInteger) (con integer 10) ] y ]
                    ]
                    False
                  ]
                  True
                ]
              )
            ]
            [
              [
                {
                  (abs
                    a
                    (type)
                    (lam
                      c
                      (fun (con integer) (fun a a))
                      (lam
                        n
                        a
                        [
                          [ c (con integer 1) ]
                          [
                            [ c (con integer 2) ]
                            [
                              [ c (con integer 3) ]
                              [
                                [ c (con integer 4) ]
                                [
                                  [ c (con integer 5) ]
                                  [
                                    [ c (con integer 6) ]
                                    [
                                      [ c (con integer 7) ]
                                      [
                                        [ c (con integer 8) ]
                                        [
                                          [ c (con integer 9) ]
                                          [ [ c (con integer 10) ] n ]
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      )
                    )
                  )
                  [ List (con integer) ]
                }
                { Cons (con integer) }
              ]
              { Nil (con integer) }
            ]
          ]
        )
      )
    )
  )
)